#!/usr/bin/env python3
"""
Flask web app for git-sweaty: Strava OAuth and personal dashboard.
"""
import os
import secrets
import shutil
import subprocess
import sys
import threading
import urllib.parse
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

from flask import Flask, redirect, render_template, request, session, send_from_directory, url_for

# Pipeline status (updated by background thread)
_pipeline_lock = threading.Lock()
_pipeline_running = False
_pipeline_last_run_at = None
_pipeline_last_success = None

# Add scripts to path for pipeline imports
SCRIPT_DIR = Path(__file__).resolve().parent / "scripts"
sys.path.insert(0, str(SCRIPT_DIR.parent))

app = Flask(__name__)
app.secret_key = os.environ.get("SECRET_KEY", secrets.token_hex(32))

ROOT = Path(__file__).resolve().parent
DASHBOARD_SITE_DIR = ROOT / "site"
DASHBOARD_SOURCE_DIR = ROOT / "docs" / "site"
DB_PATH = ROOT / "tokens.db"
CONFIG_LOCAL = ROOT / "config.local.yaml"
DATA_DIR = os.environ.get("DATA_DIR")
DATA_JSON_PATH = Path(DATA_DIR) / "data.json" if DATA_DIR else DASHBOARD_SITE_DIR / "data.json"

STRAVA_AUTHORIZE = "https://www.strava.com/oauth/authorize"
STRAVA_TOKEN = "https://www.strava.com/oauth/token"
STRAVA_SCOPE = "read,activity:read_all"


def _callback_url() -> str:
    """Build callback URL for Strava OAuth. Prefer explicit BASE_URL to avoid
    localhost vs 127.0.0.1 mismatch with Strava's Authorization Callback Domain.
    """
    base = os.environ.get("BASE_URL", "").rstrip("/")
    if base:
        return f"{base}/callback"
    return url_for("callback", _external=True)


def get_db():
    import sqlite3

    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db():
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS tokens (
            athlete_id INTEGER PRIMARY KEY,
            access_token TEXT NOT NULL,
            refresh_token TEXT NOT NULL,
            expires_at INTEGER NOT NULL,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL
        )
        """
    )
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS user_data (
            athlete_id INTEGER PRIMARY KEY,
            data_json TEXT NOT NULL,
            updated_at TEXT NOT NULL
        )
        """
    )
    conn.commit()
    conn.close()


# Create tables when app is loaded (e.g. by gunicorn) - main() is not called in that case
init_db()


def store_tokens(athlete_id: int, access_token: str, refresh_token: str, expires_at: int):
    from datetime import datetime, timezone

    now = datetime.now(timezone.utc).isoformat()
    conn = get_db()
    conn.execute(
        """
        INSERT INTO tokens (athlete_id, access_token, refresh_token, expires_at, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT(athlete_id) DO UPDATE SET
            access_token = excluded.access_token,
            refresh_token = excluded.refresh_token,
            expires_at = excluded.expires_at,
            updated_at = excluded.updated_at
        """,
        (athlete_id, access_token, refresh_token, expires_at, now, now),
    )
    conn.commit()
    conn.close()


def get_tokens(athlete_id: int):
    conn = get_db()
    row = conn.execute(
        "SELECT access_token, refresh_token, expires_at FROM tokens WHERE athlete_id = ?",
        (athlete_id,),
    ).fetchone()
    conn.close()
    return dict(row) if row else None


def store_user_data(athlete_id: int, data_json: str) -> None:
    from datetime import datetime, timezone

    now = datetime.now(timezone.utc).isoformat()
    conn = get_db()
    conn.execute(
        """
        INSERT INTO user_data (athlete_id, data_json, updated_at)
        VALUES (?, ?, ?)
        ON CONFLICT(athlete_id) DO UPDATE SET
            data_json = excluded.data_json,
            updated_at = excluded.updated_at
        """,
        (athlete_id, data_json, now),
    )
    conn.commit()
    conn.close()


def get_user_data(athlete_id: int) -> Optional[str]:
    conn = get_db()
    row = conn.execute(
        "SELECT data_json FROM user_data WHERE athlete_id = ?",
        (athlete_id,),
    ).fetchone()
    conn.close()
    return row["data_json"] if row else None


def ensure_dashboard_files():
    """Ensure site/ has index.html and app.js (copy from docs/site if missing)."""
    DASHBOARD_SITE_DIR.mkdir(parents=True, exist_ok=True)
    for name in ("index.html", "app.js"):
        dst = DASHBOARD_SITE_DIR / name
        src = DASHBOARD_SOURCE_DIR / name
        if not dst.exists() and src.exists():
            shutil.copy2(src, dst)


def write_user_config(refresh_token: str):
    """Write config.local.yaml with Strava credentials for the pipeline."""
    client_id = os.environ.get("STRAVA_CLIENT_ID", "")
    client_secret = os.environ.get("STRAVA_CLIENT_SECRET", "")
    content = f"""# Auto-generated by Flask app
source: strava
strava:
  client_id: "{client_id}"
  client_secret: "{client_secret}"
  refresh_token: "{refresh_token}"
"""
    CONFIG_LOCAL.write_text(content, encoding="utf-8")


def run_pipeline() -> bool:
    """Run the sync + generate pipeline. Returns True on success.
    Uses DATA_DIR from environment so pipeline writes data.json to the volume when set.
    """
    env = dict(os.environ)
    if DATA_DIR:
        env["DATA_DIR"] = DATA_DIR
    try:
        result = subprocess.run(
            [sys.executable, str(ROOT / "scripts" / "run_pipeline.py")],
            cwd=str(ROOT),
            env=env,
            capture_output=True,
            text=True,
            timeout=300,
        )
        if result.returncode != 0:
            app.logger.warning("Pipeline failed: %s", result.stderr)
            return False
        return True
    except subprocess.TimeoutExpired:
        app.logger.warning("Pipeline timed out")
        return False
    except Exception as exc:
        app.logger.exception("Pipeline error: %s", exc)
        return False


@app.route("/")
def index():
    if "athlete_id" in session:
        return redirect(url_for("dashboard"))
    return render_template("login.html")


@app.route("/login")
def login():
    state = secrets.token_urlsafe(20)
    session["oauth_state"] = state

    redirect_uri = _callback_url()
    params = {
        "client_id": os.environ.get("STRAVA_CLIENT_ID", ""),
        "response_type": "code",
        "redirect_uri": redirect_uri,
        "approval_prompt": "auto",
        "scope": STRAVA_SCOPE,
        "state": state,
    }
    auth_url = f"{STRAVA_AUTHORIZE}?{urllib.parse.urlencode(params)}"
    return redirect(auth_url)


@app.route("/callback")
def callback():
    state = request.args.get("state")
    if state != session.get("oauth_state"):
        return "Invalid state parameter. Please try again.", 400

    code = request.args.get("code")
    error = request.args.get("error")
    if error:
        return f"Strava authorization failed: {error}", 400
    if not code:
        return "Missing code. Please try connecting again.", 400

    # Exchange code for tokens
    import urllib.request

    redirect_uri = _callback_url()
    data = urllib.parse.urlencode(
        {
            "client_id": os.environ.get("STRAVA_CLIENT_ID", ""),
            "client_secret": os.environ.get("STRAVA_CLIENT_SECRET", ""),
            "code": code,
            "grant_type": "authorization_code",
            "redirect_uri": redirect_uri,
        }
    ).encode("utf-8")

    req = urllib.request.Request(
        STRAVA_TOKEN,
        data=data,
        method="POST",
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            payload = __import__("json").loads(resp.read().decode())
    except Exception as exc:
        app.logger.exception("Token exchange failed: %s", exc)
        return f"Failed to exchange authorization code: {exc}", 500

    athlete = payload.get("athlete") or {}
    athlete_id = athlete.get("id")
    if not athlete_id:
        return "Strava response missing athlete id.", 500

    access_token = payload.get("access_token")
    refresh_token = payload.get("refresh_token")
    expires_at = payload.get("expires_at", 0)
    if not access_token or not refresh_token:
        return "Strava response missing tokens.", 500

    store_tokens(athlete_id, access_token, refresh_token, expires_at)
    session["athlete_id"] = athlete_id
    session.pop("oauth_state", None)

    write_user_config(refresh_token)
    ensure_dashboard_files()

    def _run_pipeline_background():
        global _pipeline_running, _pipeline_last_run_at, _pipeline_last_success
        with _pipeline_lock:
            _pipeline_running = True
        try:
            success = run_pipeline()
            if success and DATA_JSON_PATH.exists():
                data_json = DATA_JSON_PATH.read_text(encoding="utf-8")
                store_user_data(athlete_id, data_json)
            with _pipeline_lock:
                _pipeline_last_run_at = datetime.now(timezone.utc)
                _pipeline_last_success = success
        except Exception as exc:
            app.logger.exception("Background pipeline failed: %s", exc)
            with _pipeline_lock:
                _pipeline_last_run_at = datetime.now(timezone.utc)
                _pipeline_last_success = False
        finally:
            with _pipeline_lock:
                _pipeline_running = False

    threading.Thread(target=_run_pipeline_background, daemon=True).start()
    return redirect(url_for("dashboard"))


@app.route("/dashboard")
@app.route("/dashboard/")
def dashboard():
    athlete_id = session.get("athlete_id")
    if not athlete_id:
        return redirect(url_for("index"))

    tokens = get_tokens(athlete_id)
    if not tokens:
        session.pop("athlete_id", None)
        return redirect(url_for("index"))

    ensure_dashboard_files()
    # Ensure config is current (e.g. after app restart)
    write_user_config(tokens["refresh_token"])
    # Run pipeline if no user data yet (e.g. first visit after OAuth or redeploy)
    if get_user_data(athlete_id) is None:
        success = run_pipeline()
        if success and DATA_JSON_PATH.exists():
            store_user_data(athlete_id, DATA_JSON_PATH.read_text(encoding="utf-8"))

    return send_from_directory(DASHBOARD_SITE_DIR, "index.html")


@app.route("/dashboard/<path:filename>")
def dashboard_static(filename):
    if "athlete_id" not in session:
        return redirect(url_for("index"))

    safe = Path(filename)
    if safe.suffix not in (".js", ".json", ".css", ".ico", ".png", ".svg"):
        return "Not found", 404

    # Serve data.json from SQLite (persists across deploys)
    if filename == "data.json":
        athlete_id = session.get("athlete_id")
        data_json = get_user_data(athlete_id) if athlete_id else None
        if data_json is not None:
            from flask import Response
            return Response(data_json, mimetype="application/json")
        return "No dashboard data yet. Connect Strava and wait for the pipeline to complete.", 404

    return send_from_directory(DASHBOARD_SITE_DIR, filename)


def _get_pipeline_status():
    """Return (running, last_run_at, last_success)."""
    with _pipeline_lock:
        return (_pipeline_running, _pipeline_last_run_at, _pipeline_last_success)


@app.route("/status")
def status():
    running, last_run_at, last_success = _get_pipeline_status()
    last_run_str = last_run_at.isoformat() if last_run_at else "never"
    last_success_str = (
        "succeeded" if last_success is True
        else "failed" if last_success is False
        else "unknown"
    )
    return (
        f"Pipeline running: {running}\n"
        f"Last run: {last_run_str}\n"
        f"Last run result: {last_success_str}\n"
    ), 200, {"Content-Type": "text/plain; charset=utf-8"}


@app.route("/logout")
def logout():
    session.clear()
    return redirect(url_for("index"))


def main():
    init_db()
    ensure_dashboard_files()
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=os.environ.get("FLASK_DEBUG", "").lower() in ("1", "true"))


if __name__ == "__main__":
    main()
