#!/usr/bin/env python3
"""
Flask web app for git-sweaty: Strava OAuth and personal dashboard.
"""
import os
import secrets
import shutil
import subprocess
import sys
import threading
import urllib.parse
from datetime import datetime, timezone
from pathlib import Path

from flask import Flask, redirect, render_template, request, session, send_from_directory, url_for

# Pipeline status (updated by background thread)
_pipeline_lock = threading.Lock()
_pipeline_running = False
_pipeline_last_run_at = None
_pipeline_last_success = None

# Add scripts to path for pipeline imports
SCRIPT_DIR = Path(__file__).resolve().parent / "scripts"
sys.path.insert(0, str(SCRIPT_DIR.parent))

app = Flask(__name__)
app.secret_key = os.environ.get("SECRET_KEY", secrets.token_hex(32))

ROOT = Path(__file__).resolve().parent
DASHBOARD_SITE_DIR = ROOT / "site"
DASHBOARD_SOURCE_DIR = ROOT / "docs" / "site"
DB_PATH = ROOT / "tokens.db"
CONFIG_LOCAL = ROOT / "config.local.yaml"

STRAVA_AUTHORIZE = "https://www.strava.com/oauth/authorize"
STRAVA_TOKEN = "https://www.strava.com/oauth/token"
STRAVA_SCOPE = "read,activity:read_all"


def _callback_url() -> str:
    """Build callback URL for Strava OAuth. Prefer explicit BASE_URL to avoid
    localhost vs 127.0.0.1 mismatch with Strava's Authorization Callback Domain.
    """
    base = os.environ.get("BASE_URL", "").rstrip("/")
    if base:
        return f"{base}/callback"
    return url_for("callback", _external=True)


def get_db():
    import sqlite3

    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db():
    conn = get_db()
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS tokens (
            athlete_id INTEGER PRIMARY KEY,
            access_token TEXT NOT NULL,
            refresh_token TEXT NOT NULL,
            expires_at INTEGER NOT NULL,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL
        )
        """
    )
    conn.commit()
    conn.close()


# Create tables when app is loaded (e.g. by gunicorn) - main() is not called in that case
init_db()


def store_tokens(athlete_id: int, access_token: str, refresh_token: str, expires_at: int):
    from datetime import datetime, timezone

    now = datetime.now(timezone.utc).isoformat()
    conn = get_db()
    conn.execute(
        """
        INSERT INTO tokens (athlete_id, access_token, refresh_token, expires_at, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT(athlete_id) DO UPDATE SET
            access_token = excluded.access_token,
            refresh_token = excluded.refresh_token,
            expires_at = excluded.expires_at,
            updated_at = excluded.updated_at
        """,
        (athlete_id, access_token, refresh_token, expires_at, now, now),
    )
    conn.commit()
    conn.close()


def get_tokens(athlete_id: int):
    conn = get_db()
    row = conn.execute(
        "SELECT access_token, refresh_token, expires_at FROM tokens WHERE athlete_id = ?",
        (athlete_id,),
    ).fetchone()
    conn.close()
    return dict(row) if row else None


def ensure_dashboard_files():
    """Ensure site/ has index.html and app.js (copy from docs/site if missing)."""
    DASHBOARD_SITE_DIR.mkdir(parents=True, exist_ok=True)
    for name in ("index.html", "app.js"):
        dst = DASHBOARD_SITE_DIR / name
        src = DASHBOARD_SOURCE_DIR / name
        if not dst.exists() and src.exists():
            shutil.copy2(src, dst)


def write_user_config(refresh_token: str):
    """Write config.local.yaml with Strava credentials for the pipeline."""
    client_id = os.environ.get("STRAVA_CLIENT_ID", "")
    client_secret = os.environ.get("STRAVA_CLIENT_SECRET", "")
    content = f"""# Auto-generated by Flask app
source: strava
strava:
  client_id: "{client_id}"
  client_secret: "{client_secret}"
  refresh_token: "{refresh_token}"
"""
    CONFIG_LOCAL.write_text(content, encoding="utf-8")


def run_pipeline() -> bool:
    """Run the sync + generate pipeline. Returns True on success."""
    try:
        result = subprocess.run(
            [sys.executable, str(ROOT / "scripts" / "run_pipeline.py")],
            cwd=str(ROOT),
            capture_output=True,
            text=True,
            timeout=300,
        )
        if result.returncode != 0:
            app.logger.warning("Pipeline failed: %s", result.stderr)
            return False
        return True
    except subprocess.TimeoutExpired:
        app.logger.warning("Pipeline timed out")
        return False
    except Exception as exc:
        app.logger.exception("Pipeline error: %s", exc)
        return False


@app.route("/")
def index():
    if "athlete_id" in session:
        return redirect(url_for("dashboard"))
    return render_template("login.html")


@app.route("/login")
def login():
    state = secrets.token_urlsafe(20)
    session["oauth_state"] = state

    redirect_uri = _callback_url()
    params = {
        "client_id": os.environ.get("STRAVA_CLIENT_ID", ""),
        "response_type": "code",
        "redirect_uri": redirect_uri,
        "approval_prompt": "auto",
        "scope": STRAVA_SCOPE,
        "state": state,
    }
    auth_url = f"{STRAVA_AUTHORIZE}?{urllib.parse.urlencode(params)}"
    return redirect(auth_url)


@app.route("/callback")
def callback():
    state = request.args.get("state")
    if state != session.get("oauth_state"):
        return "Invalid state parameter. Please try again.", 400

    code = request.args.get("code")
    error = request.args.get("error")
    if error:
        return f"Strava authorization failed: {error}", 400
    if not code:
        return "Missing code. Please try connecting again.", 400

    # Exchange code for tokens
    import urllib.request

    redirect_uri = _callback_url()
    data = urllib.parse.urlencode(
        {
            "client_id": os.environ.get("STRAVA_CLIENT_ID", ""),
            "client_secret": os.environ.get("STRAVA_CLIENT_SECRET", ""),
            "code": code,
            "grant_type": "authorization_code",
            "redirect_uri": redirect_uri,
        }
    ).encode("utf-8")

    req = urllib.request.Request(
        STRAVA_TOKEN,
        data=data,
        method="POST",
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            payload = __import__("json").loads(resp.read().decode())
    except Exception as exc:
        app.logger.exception("Token exchange failed: %s", exc)
        return f"Failed to exchange authorization code: {exc}", 500

    athlete = payload.get("athlete") or {}
    athlete_id = athlete.get("id")
    if not athlete_id:
        return "Strava response missing athlete id.", 500

    access_token = payload.get("access_token")
    refresh_token = payload.get("refresh_token")
    expires_at = payload.get("expires_at", 0)
    if not access_token or not refresh_token:
        return "Strava response missing tokens.", 500

    store_tokens(athlete_id, access_token, refresh_token, expires_at)
    session["athlete_id"] = athlete_id
    session.pop("oauth_state", None)

    write_user_config(refresh_token)
    ensure_dashboard_files()

    def _run_pipeline_background():
        global _pipeline_running, _pipeline_last_run_at, _pipeline_last_success
        with _pipeline_lock:
            _pipeline_running = True
        try:
            success = run_pipeline()
            with _pipeline_lock:
                _pipeline_last_run_at = datetime.now(timezone.utc)
                _pipeline_last_success = success
        except Exception as exc:
            app.logger.exception("Background pipeline failed: %s", exc)
            with _pipeline_lock:
                _pipeline_last_run_at = datetime.now(timezone.utc)
                _pipeline_last_success = False
        finally:
            with _pipeline_lock:
                _pipeline_running = False

    threading.Thread(target=_run_pipeline_background, daemon=True).start()
    return redirect(url_for("dashboard"))


@app.route("/dashboard")
@app.route("/dashboard/")
def dashboard():
    athlete_id = session.get("athlete_id")
    if not athlete_id:
        return redirect(url_for("index"))

    tokens = get_tokens(athlete_id)
    if not tokens:
        session.pop("athlete_id", None)
        return redirect(url_for("index"))

    ensure_dashboard_files()
    # Ensure config is current (e.g. after app restart)
    write_user_config(tokens["refresh_token"])
    # Run pipeline if no data yet (e.g. first visit after OAuth)
    data_json = DASHBOARD_SITE_DIR / "data.json"
    if not data_json.exists():
        run_pipeline()

    return send_from_directory(DASHBOARD_SITE_DIR, "index.html")


@app.route("/dashboard/<path:filename>")
def dashboard_static(filename):
    if "athlete_id" not in session:
        return redirect(url_for("index"))

    safe = Path(filename)
    if safe.suffix not in (".js", ".json", ".css", ".ico", ".png", ".svg"):
        return "Not found", 404

    return send_from_directory(DASHBOARD_SITE_DIR, filename)


def _get_pipeline_status():
    """Return (running, last_run_at, last_success)."""
    with _pipeline_lock:
        return (_pipeline_running, _pipeline_last_run_at, _pipeline_last_success)


@app.route("/status")
def status():
    running, last_run_at, last_success = _get_pipeline_status()
    last_run_str = last_run_at.isoformat() if last_run_at else "never"
    last_success_str = (
        "succeeded" if last_success is True
        else "failed" if last_success is False
        else "unknown"
    )
    return (
        f"Pipeline running: {running}\n"
        f"Last run: {last_run_str}\n"
        f"Last run result: {last_success_str}\n"
    ), 200, {"Content-Type": "text/plain; charset=utf-8"}


@app.route("/logout")
def logout():
    session.clear()
    return redirect(url_for("index"))


def main():
    init_db()
    ensure_dashboard_files()
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=os.environ.get("FLASK_DEBUG", "").lower() in ("1", "true"))


if __name__ == "__main__":
    main()
